VULNERABLE: YES
VULNERABLE_LINES: Lines 113-114
VULNERABILITY_DESCRIPTION:
Outdated functions.
EXPLANATION:
The function OBJ_obj2txt() is used to generate human-readable format of object identifier. However, its use can lead to insecure practices. OpenSSL version 1.1.0 and later removed support for the OBJ_obj2txt_len() and OBJ_obj2txt() functions. If the function is used in code, a security risk might arise if not properly handled.

Also, the BIO_get_mem_ptr() function does not check for the existence of a memory BIO. An attacker could craft a certificate that would cause the function to return NULL, potentially leading to unexpected program behavior or crashes.

In addition, X509V3_EXT_print() and GENERAL_NAME_print() do not check for bounds, and could write beyond the buffer.

Another issue exists in zend_parse_parameters. The string that is read from zend_parse_parameters  is never freed, which could lead to a memory leak in a loop.

Finally, EVP_PKEY *pkey = NULL; is assigned but not used. Similarly, NETSCAPE_SPKI *spki = NULL; is assigned but not used. Both variables are potential memory leaks.

RECOMMENDATIONS:
- Use OBJ_obj2nid() and OBJ_nid2sn() instead of OBJ_obj2txt() for getting the human-readable name of an OID.
- Use BIO_set_mem_buf() instead of BIO_get_mem_ptr() for memory BIOs.
- Use ASN1_STRING_get0_data() and ASN1_STRING_get0_length() for safely getting the contents of an ASN1_STRING.
- Implement checks and bounds for BIO_puts(), BIO_write() and GENERAL_NAME_print() functions for the existence of memory BIOs.
- Consider using BIO_printf() or ASN1_STRING_print_ex() instead of BIO_write() or GENERAL_NAME_print().
- Consider freeing allocated strings using zend_parse_parameters strings to avoid memory leaks.

ORIGINAL CODE:

 for (i = 0; i < X509_NAME_entry_count(name); i++) {
 	unsigned char *to_add;
 	int to_add_len = 0;
	
 	ne  = X509_NAME_get_entry(name, i);
 	obj = X509_NAME_ENTRY_get_object(ne);
 EVP_PKEY *pkey = NULL;
 	NETSCAPE_SPKI *spki = NULL;
 	BIO *out = BIO_new(BIO_s_mem());
 
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &spkstr, &spkstr_len) == FAILURE) {
 		return;
 	}
 }

 static int openssl_x509v3_subjectAltName(BIO *bio, X509_EXTENSION *extension)
 {
 	GENERAL_NAMES *names;
 	const X509V3_EXT_METHOD *method = NULL;
 	long i, length, num;
 	const unsigned char *p;

 	method = X509V3_EXT_get(extension);
 	if (method == NULL) {
 		return -1;
 	}

 	p = extension->value->data;
 	length = extension->value->length;
 	if (method->it) {
 		names = (GENERAL_NAMES*)(ASN1_item_d2i(NULL, &p, length,
 					       ASN1_ITEM_ptr(method->it)));
 	} else {
 		names = (GENERAL_NAMES*)(method->d2i(NULL, &p, length));
 	}
 	if (names == NULL) {
 		return -1;
 	}

 	num = sk_GENERAL_NAME_num(names);
 	for (i = 0; i < num; i++) {
 			GENERAL_NAME *name;
 			ASN1_STRING *as;
 			name = sk_GENERAL_NAME_value(names, i);
 			switch (name->type) {
 				case GEN_EMAIL:
 					BIO_puts(bio, "email:");
 					as = name->d.rfc822Name;
 					BIO_write(bio, ASN1_STRING_data(as),
 					      ASN1_STRING_length(as));
 					break;
 				case GEN_DNS:
 					BIO_puts(bio, "DNS:");
 					as = name->d.dNSName;
 					BIO_write(bio, ASN1_STRING_data(as),
 					      ASN1_STRING_length(as));
 					break;
 				case GEN_URI:
 					BIO_puts(bio, "URI:");
 					as = name->d.uniformResourceIdentifier;
 					BIO_write(bio, ASN1_STRING_data(as),
 					      ASN1_STRING_length(as));
 					break;
 				default:
 					/* use builtin print for GEN_OTHERNAME, GEN_X400,
 					 * GEN_EDIPARTY, GEN_DIRNAME, GEN_IPADD and GEN_RID
 					 */
 					GENERAL_NAME_print(bio, name);
 			}
 			/* trailing ', ' except for last element */
 			if (i < (num - 1)) {
 				BIO_puts(bio, ", ");
 			}
 	}
 	sk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);
 
 	return 0;
 }
 
 PHP_FUNCTION(openssl_x509_parse)
 {
 
 
 	for (i = 0; i < X509_get_ext_count(cert); i++) {
 		int nid;
 		extension = X509_get_ext(cert, i);
 		nid = OBJ_obj2nid(X509_EXTENSION_get_object(extension));
 		if (nid != NID_undef) {
 			extname = (char *)OBJ_nid2sn(OBJ_obj2nid(X509_EXTENSION_get_object(extension)));
 		} else {
 			OBJ_obj2txt(buf, sizeof(buf)-1, X509_EXTENSION_get_object(extension), 1);
 			extname = buf;
 		}
 		bio_out = BIO_new(BIO_s_mem());
 		if (nid == NID_subject_alt_name) {
 			if (openssl_x509v3_subjectAltName(bio_out, extension) == 0) {
 				add_assoc_stringl(subitem, extname, bio_buf->data, bio_buf->length, 1);
 			} else {
 				zval_dtor(return_value);
 				if (certresource == -1 && cert) {
 					X509_free(cert);
 				}
 				BIO_free(bio_out);
 				RETURN_FALSE;
 			}
 		}
 		else if (X509V3_EXT_print(bio_out, extension, 0, 0)) {
 			BIO_get_mem_ptr(bio_out, &bio_buf);
 			add_assoc_stringl(subitem, extname, bio_buf->data, bio_buf->length, 1);
 		} else {
 			add_assoc_asn1_string(subitem, extname, X509_EXTENSION_get_data(extension));
