VULNERABLE: YES
VULNERABLE_LINES: 7-8
VULNERABILITY_DESCRIPTION:
Use of InterlockedOr64 with non-temporal stores may cause data exposure.
EXPLANATION:
The CRYPTO_atomic_load and CRYPTO_atomic_or functions are used to atomically load and update 64-bit values. However, in the CRYPTO_atomic_load function, the InterlockedOr64 function is used with a non-temporal store (the op parameter is 0), which may expose the loaded value. This is because InterlockedOr64 modifies the original value and returns it, which could be observable by other threads.
RECOMMENDATIONS:
To mitigate this vulnerability, consider using InterlockedCompareExchange64 or other atomic instructions that do not modify the original value, or ensure that the loaded value is properly synchronized between threads. Additionally, consider adding proper synchronization using the CRYPTO_RWLOCK to prevent concurrent access.

ORIGINAL CODE:

/*
 * Copyright 2016-2021 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
# endif
#endif

#include <openssl/crypto.h>

#if defined(OPENSSL_THREADS) && !defined(CRYPTO_TDEBUG) && defined(OPENSSL_SYS_WINDOWS)

int CRYPTO_atomic_or(uint64_t *val, uint64_t op, uint64_t *ret,
                     CRYPTO_RWLOCK *lock)
{
    *ret = (uint64_t)InterlockedOr64((LONG64 volatile *)val, (LONG64)op) | op;
    return 1;
}

int CRYPTO_atomic_load(uint64_t *val, uint64_t *ret, CRYPTO_RWLOCK *lock)
{
    *ret = (uint64_t)InterlockedOr64((LONG64 volatile *)val, 0);
    return 1;
}

int openssl_init_fork_handlers(void)