VULNERABLE: YES
VULNERABLE_LINES: 8
VULNERABILITY_DESCRIPTION:
Out-of-bounds array access.

EXPLANATION:
The function `float_calc` contains a logic error in the array `x` indexing. The loop starts from 2, and the array `x` is accessed using `number - 1` and `number - 2`. However, for the first iteration when `number` is 2, `x[number - 2]` is equivalent to `x[0]` and `x[number - 1]` is equivalent to `x[1]`, which are correct. 

However, the issue arises when `turns` is smaller than 2 because the loop `for_each` will not be executed, resulting in accessing an index in `x` that is out of bounds when `x[turns]` is called at the end of `float_calc`. 

Moreover, even when `turns` is greater than or equal to 2, if `turns` is not zero-based and the last index for the array `x` is less than `turns`, then again an out-of-bounds error occurs.

RECOMMENDATIONS:
There are multiple ways to handle this situation:

1. Change the indexing of `x[turns]` to `x[turns - 1]` to avoid out-of-bounds indexing.
2. Check the value of `turns` and return an error if `turns` is smaller than 2 or greater than the current size of `x - 1`.
3. Use safe index check using `get` function: `x.get(turns - 1)`

ORIGINAL CODE:


		      fn rec_float(y: f64, z: f64) -> f64 
		      {
		      
			108.0 - ((815.0 - 1500.0 / z) / y);
		      
		      }
		      
		      fn float_calc(turns: usize) -> f64 
		      {
		      
			let mut x: Vec<f64> = vec![4.0, 4.25];
			(2..turns + 1).for_each(|number| 
			{
			
			  x.push(rec_float(x[number - 1], x[number - 2]));
			
			});
			
			x[turns]
		      
		      }