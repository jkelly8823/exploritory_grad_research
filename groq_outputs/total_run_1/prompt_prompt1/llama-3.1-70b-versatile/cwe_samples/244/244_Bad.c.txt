VULNERABLE: YES
VULNERABLE_LINES: 2
VULNERABILITY_DESCRIPTION: Insecure Use of Realloc for Sensitive Data
EXPLANATION:
When reallocated memory isn't secure in secure code, especially when dealing with sensitive information, there's a possibility the sensitive data remains in system memory, where it can be exploited by other processes. In this provided snippet, a secret is retrieved from `get_secret()` into `cleartext_buffer`. This memory is later deallocated, which doesn't securely erase it. It becomes vulnerable after allocation to have its memory, but contents of the previous information remain to exist.


The use of `realloc()` can exacerbate this problem as data isn't immediately zeroized. Zeroing the memory after reallocation with sensitive data before doing other tasks on such is important.


It should also be noted that  `scrub_memory(cleartext_buffer, 1024);` after making new memory space allocation still doesn't zero previous memory space information made of sensitive data:


RECOMMENDATIONS:
Use `calloc()` or `malloc()` before overwriting data from previously sensitive items, then zeroize left over memory details such as these sensitive facts after securely processing them. Allocate zero memory instead to remove possibilities where data breach could happen sooner rather  securely deallocate.


- Avoid using sensitive & critical information if or anywhere, one knows what original reallocation actions for memory did/did, use less probable way.



ORIGINAL CODE:
```
cleartext_buffer = get_secret();...cleartext_buffer = realloc(cleartext_buffer, 1024);...scrub_memory(cleartext_buffer, 1024);
```