VULNERABLE: YES
VULNERABLE_LINES: 1
VULNERABILITY_DESCRIPTION:
Assignment instead of equality check in conditional statement

EXPLANATION:
The vulnerability is due to the assignment `cert = SSL_get_peer_certificate(ssl)` inside the conditional statement, which is evaluated as an expression. In C, a single equals sign '=' is the assignment operator, and its result is the value assigned. In this context, the assignment `cert = SSL_get_peer_certificate(ssl)` is evaluated as true if the certificate is not null, but it is vulnerable to a silent failure if an attacker provides a null certificate.

The bigger concern with this assignment within the conditional statement is that it disguises a potential logic bug. The intention of the statement is likely to check if the function call's result is not null before moving on, however, if the intention was to compare rather than assign, the use of '=' instead of '==' would be considered a logic error in this context.

However, in this case, the code does have a condition verification right after, where it does correctly validate the cert by using '=='.

RECOMMENDATIONS:
For this specific line of code considering there's a check right after this line we do not suggest any modifications as changing it may lead to errors, however still in the real-world scenario and with large codebase.

For securing the original intent of code,
if ((cert = SSL_get_peer_certificate(ssl)) && (X509_V_OK == foo || X509_V_ERRCERT_NOT_YET_VALID == foo))
could have been considered if there was no condition after that line.
Also changing the error checking is always good practice.

ORIGINAL CODE:

if (cert = SSL_get_peer_certificate(ssl)) {
    foo=SSL_get_verify_result(ssl);if ((X509_V_OK==foo) || (X509_V_ERRCERT_NOT_YET_VALID==foo))
    //do stuff     
}
Please make sure checking modifications is run on real code during the implementation