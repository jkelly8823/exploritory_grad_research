VULNERABLE: YES
VULNERABLE_LINES: 8-10
VULNERABILITY_DESCRIPTION: 
Unvalidated data is being stored in a buffer, potentially leading to a buffer overflow vulnerability.

EXPLANATION:
In the provided code snippet, data received from a socket is being scanned into variables using sscanf. The data is expected to be in the format of two decimal numbers separated by a space, however, there is no validation that the data actually adheres to this format or that it is within a valid range. The sscanf function returns the number of successful assignments, but does not prevent buffer overflow if the input data is longer than the expected format. Furthermore, the sscanf function can overflow the buffers of the variables num and size if the data is numeric but outside the range of an int, potentially overwriting adjacent memory locations.

However, the largest concern lies in the fact that there is no validation that num is within the array bounds of sizes before assignment. If the received data from the socket could be controlled by an attacker, they could potentially overflow the sizes array, leading to an arbitrary write vulnerability.

RECOMMENDATIONS:
- Validate data received from the socket before assigning it to variables. Ensure that num is within the bounds of the sizes array and that size is a reasonable value before assigning.
- Consider using functions that prevent buffer overflow, such as fgets and atoi instead of sscanf.
- Implement bounds checking to ensure that the size of the received data does not exceed the buffer size.

ORIGINAL CODE:


                  /* capture the sizes of all messages */
                     int getsizes(int sock, int count, int *sizes) {
                        ...char buf[BUFFER_SIZE];int ok;int num, size;
                           
                           // read values from socket and added to sizes array
                           while ((ok = gen_recv(sock, buf, sizeof(buf))) == 0){
                              
                                 
                                 // continue read from socket until buf only contains '.'
                                 if (DOTLINE(buf))break;
                                 else if (sscanf(buf, "%d %d", &num, &size) == 2)sizes[num - 1] = size;
                              
                           }...
                        
                     }
               