[
    {
        "vulnerability_name": "global-buffer-overflow",
        "description": "A global-buffer-overflow occurs when a program reads or writes more data to a global or file-static buffer than it was allocated for. These buffers reside in the .data or .bss sections and are allocated in memory before main() starts. The overflow happens because the program mistakenly accesses memory outside the bounds of a global or static variable. This can lead to undefined behavior, crashes, or security vulnerabilities such as data corruption or remote code execution. In C, a global variable can be declared in several source files, and each definition can have different types. The compiler can't see all possible definitions at once, but the linker can. For C, the linker defaults to selecting the largest-sized variable out of all the different declarations. In C++, a global is allocated by the compiler, and there can only be one definition. Therefore, the size of each definition is known at compile time, but incorrect memory access can still occur. Global-buffer-overflow errors often arise from programming mistakes such as incorrect array indexing, improper memory allocation, or misunderstanding of variable scope.",
        "examples": [
            {
                "language": "C",
                "description": "In this example, global variables 'x' are defined in three different source files with varying types. When the variables are linked, the linker selects the largest-sized variable among all definitions. However, in 'example1-main.c', the code mistakenly accesses an out-of-bounds index in 'x', causing a global-buffer-overflow.",
                "code": "// file: a.c\nint x;\n\n// file: b.c\nchar* x;\n\n// file: c.c\nfloat* x[3];\n\n// file: example1-main.c\n// global-buffer-overflow error\n\n// AddressSanitizer reports a buffer overflow at the first line\n// in function main() in all cases, REGARDLESS of the order in \n// which the object files: a.obj, b.obj, and c.obj are linked.\n  \ndouble x[5];\n \nint main() { \n    int rc = (int) x[5];  // Boom!\n    return rc; \n}"
            },
            {
                "language": "C++",
                "description": "In this example, static arrays are used at the function level. When accessing 'YYY[argc * 10]', the program attempts to access memory beyond the allocated size of the array, resulting in a global-buffer-overflow.",
                "code": "// example2.cpp\n// global-buffer-overflow error\n#include <string.h>\n\nint main(int argc, char **argv) {\n    static char XXX[10];\n    static char YYY[10];\n    static char ZZZ[10];\n\n    memset(XXX, 0, 10); memset(YYY, 0, 10); memset(ZZZ, 0, 10);\n\n    int res = YYY[argc * 10];  // Boom!\n    res += XXX[argc] + ZZZ[argc];\n    return res;\n}"
            },
            {
                "language": "C++",
                "description": "This example shows different ways of causing a global-buffer-overflow in C++ by accessing globals, class statics, function statics, or string literals. The case of '-g' accesses 'global[one * 11]', causing an out-of-bounds access.",
                "code": "// example3.cpp\n// global-buffer-overflow error\n\n#include <string.h>\n\nstruct C {\n    static int array[10];\n};\n\n// normal global\nint global[10];\n\n// class static\nint C::array[10];\n\nint main(int argc, char **argv) {\n\n    int one = argc - 1;\n\n    switch (argv[1][1]) {\n    case 'g': return global[one * 11];     //Boom! simple global\n    case 'c': return C::array[one * 11];   //Boom! class static\n    case 'f':\n    {\n        static int array[10] = {};\n        return array[one * 11];            //Boom! function static\n    }\n    case 'l':\n        // literal global ptr created by compiler\n        const char *str = \"0123456789\";\n        return str[one * 11];              //Boom! .rdata string literal allocated by compiler\n    }\n    return 0;\n}"
            }
        ],
        "reproduction_file": "./database/reproduction/global_buffer_overflow_reproduction.txt",
        "patch_file": "./database/patch/global_buffer_overflow_patch.diff"
    },

    {
        "vulnerability_name": "alloc-dealloc-mismatch",
        "description": "An alloc-dealloc-mismatch error occurs when memory is allocated and deallocated using different memory management functions. For example, using `new` to allocate memory but `free` to deallocate it, or using `malloc` to allocate memory but `delete` to deallocate it. These mismatches can lead to undefined behavior, memory corruption, and program crashes. AddressSanitizer can detect these mismatches by checking the consistency of memory allocation and deallocation operations.",
        "examples": [
            {
                "language": "C++",
                "description": "In this example, a mismatch between memory allocation and deallocation APIs occurs. Using `new int[10]` for allocation and `delete` for deallocation causes an alloc-dealloc-mismatch error.",
                "code": "// example1.cpp\n// alloc-dealloc-mismatch error\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char* argv[]) {\n\n    if (argc != 2) return -1;\n\n    switch (atoi(argv[1])) {\n\n    case 1:\n        delete[](new int[10]);\n        break;\n    case 2:\n        delete (new int[10]);      // Boom!\n        break;\n    default:\n        printf(\"arguments: 1: no error 2: runtime error\\n\");\n        return -1;\n    }\n\n    return 0;\n}"
            }
        ],
        "reproduction_file": "./database/reproduction/alloc_dealloc_mismatch_reproduction.txt",
        "patch_file": "./database/patch/alloc_dealloc_mismatch_patch.diff"
    },
    {
        "vulnerability_name": "allocation-size-too-big",
        "description": "An allocation-size-too-big error occurs when a program tries to allocate a block of memory that is too large for the heap or exceeds the system's memory limit. This can lead to program crashes and undefined behavior. AddressSanitizer detects this error by checking the size of memory allocation requests and comparing them to the available heap size.",
        "examples": [
            {
                "language": "C++",
                "description": "In this example, the program tries to allocate a very large memory block using `malloc` with dimensions that exceed the heap's capacity. This results in an allocation-size-too-big error.",
                "code": "// example1.cpp\n// allocation-size-too-big error\n#include <stdio.h>\n#include <malloc.h>\n#include <memory.h>\n\nint x = 1000;\nint y = 1000;\n\n__declspec(noinline) void bad_function() {\n\n  char* buffer = (char*)malloc(x * y * x * y); //Boom!\n\n  memcpy(buffer, buffer + 8, 8);\n}\n\nint main(int argc, char **argv) {\n    bad_function();\n    return 0;\n}"
            }
        ],
        "reproduction_file": "./database/reproduction/allocation_size_too_big_reproduction.txt",
        "patch_file": "./database/patch/allocation_size_too_big_patch.diff"
    },

    {
        "vulnerability_name": "SEGV",
        "description": "A segmentation fault (SIGSEGV) occurs when a program attempts to access an unknown or invalid memory address that it is not allowed to access. This can happen due to bugs in the program, such as accessing memory beyond the bounds of allocated arrays, or dereferencing an uninitialized or corrupted pointer. When an invalid memory access occurs, the operating system sends a SIGSEGV signal to the process that caused the violation, terminating the process to prevent further corruption or undefined behavior.",
        "examples": [
            {
                "language": "C",
                "description": "This example demonstrates a segmentation fault caused by accessing an unknown address. The pointer 'p' is set to an arbitrary memory address (0xC0000fff), which is not accessible in user-mode programs.",
                "code": "#include <stdio.h>\n#include <stdlib.h>\nint main() {\n    int* p = (int*)0xC0000fff;\n    *p = 10;  // SIGSEGV occurs here\n}"
            },
            {
                "language": "C",
                "description": "This example demonstrates a segmentation fault caused by dereferencing an uninitialized pointer. The pointer 'p' is declared but not initialized, leading to access to an unknown address.",
                "code": "#include <stdio.h>\n#include <stdlib.h>\nint main() {\n    int *p;  // Uninitialized pointer\n    *p = 10;  // SIGSEGV occurs here\n}"
            },
            {
                "language": "C",
                "description": "This example demonstrates a segmentation fault caused by using a pointer after it has been freed. After freeing the memory allocated to 'p', any further access to 'p' would lead to accessing an unknown or invalid address.",
                "code": "#include <stdio.h>\n#include <stdlib.h>\nint main() {\n    int *p = malloc(sizeof(int));\n    free(p);\n    *p = 10;  // SIGSEGV occurs here\n}"
            }
        ],
        "reproduction_file": "./database/reproduction/segmentation_fault_reproduction.txt",
        "patch_file": "./database/patch/segmentation_fault_patch.diff"
    }

]