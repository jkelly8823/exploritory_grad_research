 

VULNERABLE: YES
VULNERABLE_LINES: 6-8
VULNERABILITY_DESCRIPTION: A race condition exists in this code. The function au1000_hard_stop() is called before the MAC is fully reset. This can cause the MAC to be stopped while it is still being reset, leading to unpredictable behavior.
EXPLANATION: The issue arises from the fact that the MAC reset sequence is not atomic. The function au1000_hard_stop() is called before the MAC is fully reset, which can cause the MAC to be stopped while it is still being reset. This can lead to unpredictable behavior and potentially cause the system to crash.
RECOMMENDATIONS: To fix this issue, the function au1000_hard_stop() should be called after the MAC reset sequence is complete. This can be achieved by moving the call to au1000_hard_stop() after the last write to the enable register. Additionally, the MAC reset sequence should be made atomic by using a lock or other synchronization mechanism to ensure that the MAC is not stopped while it is being reset. For example, the code could be modified as follows: spin_lock_irqsave(&aup->lock, flags);... au_sync_delay(2); spin_unlock_irqrestore(&a